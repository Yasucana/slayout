(prompt "\nEnter slayout to start...")

;#######################################################;

(defun dtr (x) ;define degrees to radians function
	(* pi (/ x 180.0))
);defun

;#######################################################;

(defun set-coordinates ()
  (setq qtrdis (/ slen 4))
  (setq mkg 3)
)

;#######################################################;

(defun savevars ()
	(setq prjn (atof (get_tile "eb50"))) ;project number
  	(setq dwgn (atof (get_tile "eb51"))) ;drawing number
  	(setq revn (atof (get_tile "eb60"))) ;revision number
  	(setq hdtyp (get_tile "pl1")) ;is it hemi or semi head?
  	(setq hddsgn (get_tile "pl2")) ;is it designed inside diameter?
  	(setq shld (atof (get_tile "eb70"))) ;shell diameter
  	(setq pltt (atof (get_tile "eb75"))) ;plate thickness
  	(setq nshlr (atoi (get_tile "eb80"))) ;number of shells required
  	(setq lsof (atof (get_tile "eb90"))) ;long seam offset
  	(setq lsloc (get_tile "pl3")) ;first shell long seam on FS or NS?
	(setq slen (atof (get_tile "eb100"))) ;shell length
        (if (or (<= nshlr 0) (<= slen 0))
            (progn
                (princ "\nError: Number of shells and shell length must be positive")
                (exit)
            )
        );if
	(setq shlws (get_tile "tg30")) ;are the shells same widths through out the job?
  	(setq shlwns (get_tile "tg40")) ;are the shells not same width through out the job?
	(setq swid (atof (get_tile "eb120"))) ;width of most common shells
  	(setq ushla (atoi (get_tile "eb130"))) ;1st unique shell (a) that is different width
  	(setq ushlaw (atof (get_tile "eb140"))) ;width of shell (a)
	(setq ushlb (atoi (get_tile "eb150"))) ;2nd unique shell (b) that is different width
  	(setq ushlbw (atof (get_tile "eb160"))) ;width of shell (b)
	(setq ushlc (atoi (get_tile "eb170"))) ;3rd unique shell (c) that is different width
  	(setq ushlcw (atof (get_tile "eb180"))) ;width of shell (c)
  	;Fittings Information
	(setq var_list nil) ; Initialize var_list
	(setq i 1)
	(while (<= i 20)
	  (set (read (strcat "nzm" (itoa i))) (get_tile (strcat "eb" (itoa i) "a")))
	  (set (read (strcat "nzs" (itoa i))) (get_tile (strcat "eb" (itoa i) "b")))
	  (set (read (strcat "nzr" (itoa i))) (get_tile (strcat "eb" (itoa i) "c")))
	  (set (read (strcat "nzt" (itoa i))) (get_tile (strcat "eb" (itoa i) "d")))
	  (set (read (strcat "nzd" (itoa i))) (get_tile (strcat "eb" (itoa i) "e")))
	  (set (read (strcat "nzl" (itoa i))) (get_tile (strcat "eb" (itoa i) "f")))
	  (set (read (strcat "nzdtm" (itoa i))) (get_tile (strcat "eb" (itoa i) "g")))
	  (setq var_list (append var_list (list
	    (read (strcat "nzm" (itoa i)))
	    (read (strcat "nzs" (itoa i)))
	    (read (strcat "nzr" (itoa i)))
	    (read (strcat "nzt" (itoa i)))
	    (read (strcat "nzd" (itoa i)))
	    (read (strcat "nzl" (itoa i)))
	    (read (strcat "nzdtm" (itoa i)))
	  )))
	  (setq i (1+ i))
	);end of fitting information
);defun

;#######################################################;

; Main logic based on lsloc
(if (= (atoi lsloc) 0)
  (progn
    ; lsloc = 0: Start from bottom, offset even shells upward
    (setq start_point '(100.0 100.0 0.0))
    ; Quarter mark y-coordinates (same for all shells, calculated once)
    (setq qm_y_list (list
      (+ (cadr start_point) lsof)              ; qmt1
      (+ (cadr start_point) lsof qtrdis)       ; qmns
      (+ (cadr start_point) lsof (* 2 qtrdis)) ; qmbtm
      (+ (cadr start_point) lsof (* 3 qtrdis)) ; qmfs
      (+ (cadr start_point) lsof (* 4 qtrdis)) ; qmt2
    ))
    (setq qm_names '("qmt1" "qmns" "qmbtm" "qmfs" "qmt2"))
    (setq k 1)
    (while (<= k nshlr)
      (let ((base_x (+ (car start_point) (* (- k 1) swid)))
            (base_y (if (= (rem k 2) 0) 
                        (+ (cadr start_point) (* 2 lsof)) 
                        (cadr start_point))))
        ; Set main shell points
        (set (read (strcat "s" (itoa k) "1")) (list base_x base_y 0.0))
        (set (read (strcat "s" (itoa k) "3")) 
             (polar (eval (read (strcat "s" (itoa k) "1"))) 0 swid))
        (set (read (strcat "s" (itoa k) "7")) 
             (polar (eval (read (strcat "s" (itoa k) "1"))) (/ pi 2) slen))
        (set (read (strcat "s" (itoa k) "9")) 
             (polar (eval (read (strcat "s" (itoa k) "3"))) (/ pi 2) slen))
        ; Set corner mark points
        (set (read (strcat "s" (itoa k) "1a")) 
             (polar (eval (read (strcat "s" (itoa k) "1"))) 0 mkg))
        (set (read (strcat "s" (itoa k) "1b")) 
             (polar (eval (read (strcat "s" (itoa k) "1"))) (/ pi 2) mkg))
        (set (read (strcat "s" (itoa k) "3a")) 
             (polar (eval (strcat "s" (itoa k) "3")) pi mkg))
        (set (read (strcat "s" (itoa k) "3b")) 
             (polar (eval (strcat "s" (itoa k) "3")) (/ pi 2) mkg))
        (set (read (strcat "s" (itoa k) "9a")) 
             (polar (eval (strcat "s" (itoa k) "9")) pi mkg))
        (set (read (strcat "s" (itoa k) "9b")) 
             (polar (eval (strcat "s" (itoa k) "9")) (* 1.5 pi) mkg))
        (set (read (strcat "s" (itoa k) "7a")) 
             (polar (eval (strcat "s" (itoa k) "7")) 0 mkg))
        (set (read (strcat "s" (itoa k) "7b")) 
             (polar (eval (strcat "s" (itoa k) "7")) (* 1.5 pi) mkg))
      )
      ; Set quarter mark points
      (foreach qm qm_names
        (let ((qm_y (nth (vl-position qm qm_names) qm_y_list))
              (qm_var (strcat "s" (itoa k) qm)))
          (set (read qm_var) (list (+ (car start_point) (* (- k 1) swid)) qm_y 0.0))
          (set (read (strcat qm_var "a")) 
               (polar (eval (read qm_var)) 0 mkg))
          (set (read (strcat qm_var "b")) 
               (polar (eval (read qm_var)) 0 (- swid mkg)))
          (set (read (strcat qm_var "c")) 
               (polar (eval (read qm_var)) 0 swid))
        )
      )
      (setq k (1+ k))
    )
  )
  (progn
    ; lsloc = 1: Start from top, offset even shells downward
    (setq start_point '(100.0 100.0 0.0))
    ; Quarter mark y-coordinates (from top down)
    (setq qm_y_list (list
      (- (+ (cadr start_point) slen) lsof)              ; qmt1
      (- (+ (cadr start_point) slen) lsof qtrdis)       ; qmfs
      (- (+ (cadr start_point) slen) lsof (* 2 qtrdis)) ; qmbtm
      (- (+ (cadr start_point) slen) lsof (* 3 qtrdis)) ; qmns
      (- (+ (cadr start_point) slen) lsof (* 4 qtrdis)) ; qmt2
    ))
    (setq qm_names '("qmt1" "qmfs" "qmbtm" "qmns" "qmt2"))
    (setq k 1)
    (while (<= k nshlr)
      (let ((base_x (+ (car start_point) (* (- k 1) swid)))
            (base_y (if (= (rem k 2) 0) 
                        (- (cadr start_point) (* 2 lsof)) 
                        (cadr start_point))))
        ; Set main shell points
        (set (read (strcat "s" (itoa k) "1")) (list base_x base_y 0.0))
        (set (read (strcat "s" (itoa k) "3")) 
             (polar (eval (read (strcat "s" (itoa k) "1"))) 0 swid))
        (set (read (strcat "s" (itoa k) "7")) 
             (polar (eval (read (strcat "s" (itoa k) "1"))) (/ pi 2) slen))
        (set (read (strcat "s" (itoa k) "9")) 
             (polar (eval (read (strcat "s" (itoa k) "3"))) (/ pi 2) slen))
        ; Set corner mark points
        (set (read (strcat "s" (itoa k) "1a")) 
             (polar (eval (read (strcat "s" (itoa k) "1"))) 0 mkg))
        (set (read (strcat "s" (itoa k) "1b")) 
             (polar (eval (read (strcat "s" (itoa k) "1"))) (/ pi 2) mkg))
        (set (read (strcat "s" (itoa k) "3a")) 
             (polar (eval (strcat "s" (itoa k) "3")) pi mkg))
        (set (read (strcat "s" (itoa k) "3b")) 
             (polar (eval (strcat "s" (itoa k) "3")) (/ pi 2) mkg))
        (set (read (strcat "s" (itoa k) "9a")) 
             (polar (eval (strcat "s" (itoa k) "9")) pi mkg))
        (set (read (strcat "s" (itoa k) "9b")) 
             (polar (eval (strcat "s" (itoa k) "9")) (* 1.5 pi) mkg))
        (set (read (strcat "s" (itoa k) "7a")) 
             (polar (eval (strcat "s" (itoa k) "7")) 0 mkg))
        (set (read (strcat "s" (itoa k) "7b")) 
             (polar (eval (strcat "s" (itoa k) "7")) (* 1.5 pi) mkg))
      )
      ; Set quarter mark points
      (foreach qm qm_names
        (let ((qm_y (nth (vl-position qm qm_names) qm_y_list))
              (qm_var (strcat "s" (itoa k) qm)))
          (set (read qm_var) (list (+ (car start_point) (* (- k 1) swid)) qm_y 0.0))
          (set (read (strcat qm_var "a")) 
               (polar (eval (read qm_var)) 0 mkg))
          (set (read (strcat qm_var "b")) 
               (polar (eval (read qm_var)) 0 (- swid mkg)))
          (set (read (strcat qm_var "c")) 
               (polar (eval (read qm_var)) 0 swid))
        )
      )
      (setq k (1+ k))
    )
  )
)
(princ)

;#######################################################;

(defun parse-float (s)
  (atof s)
);defun

(defun read-hole-size-data ()
  '(
("WN" "0.125" "" "0.405")
("WN" "0.25" "" "0.54")
("WN" "0.375" "" "0.675")
("WN" "0.5" "" "0.84")
("WN" "0.75" "" "1.05")
("WN" "1" "" "1.315")
("WN" "1.25" "" "1.66")
("WN" "1.5" "" "1.9")
("WN" "2" "" "2.375")
("WN" "2.5" "" "2.875")
("WN" "3" "" "3.5")
("WN" "3.5" "" "4")
("WN" "4" "" "4.5")
("WN" "5" "" "5.563")
("WN" "6" "" "6.625")
("WN" "8" "" "8.625")
("WN" "10" "" "10.75")
("WN" "12" "" "12.75")
("WN" "14" "" "14")
("WN" "16" "" "16")
("WN" "18" "" "18")
("WN" "20" "" "20")
("WN" "22" "" "22")
("WN" "24" "" "24")
("WN" "30" "" "30")
("WN" "32" "" "32")
("WN" "34" "" "34")
("WN" "36" "" "36")
("WN" "42" "" "42")
("LWN" "0.5" "150" "1.25")
("LWN" "0.75" "150" "1.62")
("LWN" "1" "150" "2")
("LWN" "1.25" "150" "2.38")
("LWN" "1.5" "150" "2.62")
("LWN" "2" "150" "3.06")
("LWN" "2.5" "150" "3.75")
("LWN" "3" "150" "4.25")
("LWN" "3.5" "150" "4.88")
("LWN" "4" "150" "5.5")
("LWN" "5" "150" "6.5")
("LWN" "6" "150" "7.75")
("LWN" "8" "150" "9.75")
("LWN" "10" "150" "12")
("LWN" "12" "150" "14.38")
("LWN" "14" "150" "16")
("LWN" "16" "150" "18")
("LWN" "18" "150" "20")
("LWN" "20" "150" "22")
("LWN" "24" "150" "26.25")
("HB" "0.5" "150" "1.5")
("HB" "0.75" "150" "1.88")
("HB" "1" "150" "2.25")
("HB" "1.25" "150" "2.62")
("HB" "1.5" "150" "3")
("HB" "2" "150" "3.69")
("HB" "2.5" "150" "4.44")
("HB" "3" "150" "4.94")
("HB" "3.5" "150" "5.94")
("HB" "4" "150" "6.44")
("HB" "5" "150" "7.25")
("HB" "6" "150" "8.25")
("HB" "8" "150" "10.5")
("HB" "10" "150" "12.81")
("HB" "12" "150" "15.56")
("HB" "14" "150" "17.12")
("HB" "16" "150" "19.62")
("HB" "18" "150" "20.94")
("HB" "20" "150" "23.19")
("HB" "24" "150" "27.5")
("LWN" "0.5" "300" "1.5")
("LWN" "0.75" "300" "1.88")
("LWN" "1" "300" "2.12")
("LWN" "1.25" "300" "2.5")
("LWN" "1.5" "300" "2.75")
("LWN" "2" "300" "3.31")
("LWN" "2.5" "300" "3.94")
("LWN" "3" "300" "4.62")
("LWN" "3.5" "300" "5.25")
("LWN" "4" "300" "5.75")
("LWN" "5" "300" "7")
("LWN" "6" "300" "8.12")
("LWN" "8" "300" "10.25")
("LWN" "10" "300" "12.62")
("LWN" "12" "300" "14.75")
("LWN" "14" "300" "16.75")
("LWN" "16" "300" "19")
("LWN" "18" "300" "21")
("LWN" "20" "300" "23.12")
("LWN" "24" "300" "27.62")
("HB" "0.5" "300" "1.75")
("HB" "0.75" "300" "2.19")
("HB" "1" "300" "2.44")
("HB" "1.25" "300" "2.81")
("HB" "1.5" "300" "3.25")
("HB" "2" "300" "3.94")
("HB" "2.5" "300" "4.62")
("HB" "3" "300" "5.38")
("HB" "3.5" "300" "6")
("HB" "4" "300" "6.62")
("HB" "5" "300" "8")
("HB" "6" "300" "9.38")
("HB" "8" "300" "11.56")
("HB" "10" "300" "13.62")
("HB" "12" "300" "15.94")
("HB" "14" "300" "18.44")
("HB" "16" "300" "20.5")
("HB" "18" "300" "22.75")
("HB" "20" "300" "25")
("HB" "24" "300" "29.62")
  )
)

(defun find-diameter (data type nps class / fields result)
  (setq result nil)
  (while (and data (null result))
    (setq fields (car data))
    (if (and (= (length fields) 4)
             (= (nth 0 fields) type)
             (= (nth 1 fields) nps)
             (if (= class "N/A")
                 (= (nth 2 fields) "")
                 (= (nth 2 fields) class)
             )
        )
      (setq result (nth 3 fields))
    )
    (setq data (cdr data))
  )
  result
);defun

;#######################################################;

(defun display_variables ()
  (setq var_list '(
    prjn dwgn revn hdtyp hddsgn shld pltt nshlr lsof lsloc slen
    shlws shlwns swid ushla ushlaw ushlb ushlbw ushlc ushlcw
  ))
  (setq i 1)
  (while (<= i 20)
    (setq var_list (append var_list (list
      (read (strcat "nzm" (itoa i)))
      (read (strcat "nzs" (itoa i)))
      (read (strcat "nzr" (itoa i)))
      (read (strcat "nzt" (itoa i)))
      (read (strcat "nzd" (itoa i)))
      (read (strcat "nzl" (itoa i)))
      (read (strcat "nzdtm" (itoa i)))
    )))
    (setq i (1+ i))
  )
  (setq text_content "")
  (foreach var var_list
    (if (boundp var)
      (setq text_content (strcat text_content (vl-symbol-name var) " = " (vl-princ-to-string (eval var)) "\\P"))
    )
  )
  (command "mtext" '(0 0 0) "J" "TL" "H" 10 "W" 500 text_content "")
)

;#######################################################;

(defun C:slayout ()
  (setq slayout (load_dialog "slayout.dcl"))
  (if (not slayout) (progn (princ "\nError: Could not load slayout.dcl") (exit)))
  (if (not (new_dialog "slayout" slayout)) (progn (princ "\nError: Could not initialize dialog") (exit)))
  (action_tile "accept" "(setq ddiag 1)(savevars)(done_dialog)")
  (action_tile "cancel" "(setq ddiag 2)(done_dialog)")
  (start_dialog)
  (if (= ddiag 1)
    (progn
      (unload_dialog slayout)
      (set-coordinates)
      (setq data (read-hole-size-data))
      (if data
        (progn
          (setq i 1)
          (while (<= i 20)
            (let ((type (get_tile (strcat "eb" (itoa i) "d")))
                  (nps (get_tile (strcat "eb" (itoa i) "b")))
                  (class (get_tile (strcat "eb" (itoa i) "c")))
                  (mark (get_tile (strcat "eb" (itoa i) "a"))))
              (set (read (strcat "diameter" (itoa i))) (find-diameter data type nps class))
              (if (eval (read (strcat "diameter" (itoa i))))
                (progn
                  (setq size (+ (parse-float (eval (read (strcat "diameter" (itoa i))))) 0.250))
                  (princ (strcat "size of circle on " mark " = " (rtos size 2 3) "\n"))
                )
                (princ (strcat "No match found for nozzle " mark "\n"))
              )
              (setq i (1+ i))
            )
          )
        )
      )
      ;draw shells
      (setq k 1)
      (while (<= k nshlr)
        (setq p1 (eval (read (strcat "s" (itoa k) "1"))))
        (setq p3 (eval (read (strcat "s" (itoa k) "3"))))
        (setq p9 (eval (read (strcat "s" (itoa k) "9"))))
        (setq p7 (eval (read (strcat "s" (itoa k) "7"))))
        (command "pline" p1 p3 p9 p7 p1 "")
        (setq k (1+ k))
      )
      ;draw markings
      (command "layer" "n" "Punch" "c" "blue" "Punch" "")
      (command "layer" "s" "Punch" "")
      (setq m 1)
      (while (<= m nshlr)
        (setq m1a (eval (read (strcat "s" (itoa m) "1a"))))
        (setq m1 (eval (read (strcat "s" (itoa m) "1"))))
        (setq m1b (eval (read (strcat "s" (itoa m) "1b"))))
        (setq m3a (eval (read (strcat "s" (itoa m) "3a"))))
        (setq m3 (eval (read (strcat "s" (itoa m) "3"))))
        (setq m3b (eval (read (strcat "s" (itoa m) "3b"))))
        (setq m9a (eval (read (strcat "s" (itoa m) "9a"))))
        (setq m9 (eval (read (strcat "s" (itoa m) "9"))))
        (setq m9b (eval (read (strcat "s" (itoa m) "9b"))))
        (setq m7a (eval (read (strcat "s" (itoa m) "7a"))))
        (setq m7 (eval (read (strcat "s" (itoa m) "7"))))
        (setq m7b (eval (read (strcat "s" (itoa m) "7b"))))
        (command "pline" m1a m1 m1b "")
        (command "pline" m3a m3 m3b "")
        (command "pline" m9a m9 m9b "")
        (command "pline" m7a m7 m7b "")
        (setq m (1+ m))
      )
      (command "layer" "n" "Punch" "c" "blue" "Punch" "")
      (command "layer" "s" "Punch" "")
      (foreach qm '("qmt1" "qmfs" "qmbtm" "qmns" "qmt2")
        (setq k 1)
        (while (<= k nshlr)
          (let ((qm_var (strcat "s" (itoa k) qm))
                (qm_a (strcat "s" (itoa k) qm "a"))
                (qm_b (strcat "s" (itoa k) qm "b"))
                (qm_c (strcat "s" (itoa k) qm "c")))
            (command "pline" (eval (read qm_var)) (eval (read qm_a)) "")
            (command "pline" (eval (read qm_b)) (eval (read qm_c)) "")
            (if (and (> k 1) (member qm '("qmfs" "qmbtm" "qmns")))
              (command "pline" (eval (read (strcat "s" (itoa (1- k)) qm "c"))) (eval (read (strcat "s" (itoa k) qm "a"))) "")
            )
          )
          (setq k (1+ k))
        )
      )
      ;draw circles
      (setq i 1)
      (while (<= i 20)
        (setq mark_var (read (strcat "nzm" (itoa i))))
        (setq mark (eval mark_var))
        (if (and mark (/= mark ""))
          (progn
            (setq size (eval (read (strcat "nzs" (itoa i)))))
            (setq rating (eval (read (strcat "nzr" (itoa i)))))
            (setq type (eval (read (strcat "nzt" (itoa i)))))
            (setq distance (eval (read (strcat "nzd" (itoa i)))))
            (setq location (eval (read (strcat "nzl" (itoa i)))))
            (setq datum (eval (read (strcat "nzdtm" (itoa i)))))
            (cond
              ((= location "Top") (setq y (cadr s1qmt2)))
              ((= location "Bottom") (setq y (cadr s1qmbtm)))
              ((= location "NS") (setq y (cadr s1qmns)))
              ((= location "FS") (setq y (cadr s1qmfs)))
              (t (princ (strcat "Invalid location for nozzle " mark "\n")))
            )
            (if (= datum "Left")
              (setq x (+ (car s11) (atof distance)))
              (setq x (- (+ (car s11) (* nshlr swid)) (atof distance)))
            )
            (setq class (if (= rating "N/A") "" rating))
            (setq diameter_str (find-diameter data type size class))
            (if diameter_str
              (progn
                (setq diameter (atof diameter_str))
                (setq circle_diameter (+ diameter 0.25))
                (setq radius (/ circle_diameter 2.0))
                (set (read mark) (list x y 0.0))
                (command "circle" (list x y 0.0) radius)
              )
              (princ (strcat "No diameter found for nozzle " mark "\n"))
            )
          )
        )
        (setq i (1+ i))
      )
      (command "zoom" "e")
      (display_variables)
      (princ)
    )
  )
)